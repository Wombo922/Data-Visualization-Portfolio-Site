<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Playground - Interactive Analysis</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        .playground-container {
            max-width: 1400px;
            margin: 40px auto;
            padding: 20px;
        }

        .playground-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .playground-header h1 {
            font-size: 2.5em;
            color: #667eea;
            margin-bottom: 10px;
        }

        .playground-header p {
            font-size: 1.1em;
            color: #666;
        }

        .controls-panel {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 1.05em;
        }

        .control-group select,
        .control-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            position: relative;
            min-height: 400px;
        }

        .chart-canvas {
            max-height: 500px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .stat-card .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-card .stat-label {
            font-size: 1em;
            opacity: 0.9;
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: #667eea;
            font-size: 1.2em;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #c33;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1em;
        }

        .back-link:hover {
            color: #764ba2;
        }

        /* Dark mode support */
        body.dark-mode .controls-panel,
        body.dark-mode .chart-container {
            background: #16213e;
            color: #eaeaea;
        }

        body.dark-mode .control-group label {
            color: #eaeaea;
        }

        body.dark-mode .control-group select,
        body.dark-mode .control-group input {
            background: #1e2a3a;
            border-color: #2a3f5f;
            color: #eaeaea;
        }

        body.dark-mode .playground-header p {
            color: #aaa;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Dark Mode Toggle -->
    <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
        <span class="sun-icon">‚òÄÔ∏è</span>
        <span class="moon-icon">üåô</span>
    </button>

    <div class="playground-container">
        <a href="index.html" class="back-link">‚Üê Back to Portfolio</a>

        <div class="playground-header">
            <h1>üìä Interactive Data Playground</h1>
            <p>Explore market data with dynamic visualizations and real-time filtering</p>
        </div>

        <!-- Controls Panel -->
        <div class="controls-panel">
            <h2>Data Explorer Controls</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label for="dataset-select">Select Dataset</label>
                    <select id="dataset-select">
                        <option value="stocks">Tech Stocks (2 years)</option>
                        <option value="crypto">Cryptocurrency Prices</option>
                        <option value="crypto-risk">Crypto Risk/Return</option>
                        <option value="sentiment">Social Sentiment</option>
                        <option value="defi">DeFi Protocol TVL</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="chart-type">Chart Type</label>
                    <select id="chart-type">
                        <option value="line">Line Chart</option>
                        <option value="bar">Bar Chart</option>
                        <option value="scatter">Scatter Plot</option>
                    </select>
                </div>

                <div class="control-group" id="ticker-group">
                    <label for="ticker-select">Select Ticker/Asset</label>
                    <select id="ticker-select" multiple size="3">
                        <option value="all" selected>All Assets</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Statistics Cards -->
        <div id="stats-container" class="stats-grid">
            <!-- Stats will be dynamically populated -->
        </div>

        <!-- Chart Container -->
        <div class="chart-container">
            <canvas id="main-chart" class="chart-canvas"></canvas>
        </div>
    </div>

    <script>
        // Dark mode functionality
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const body = document.body;
        const savedMode = localStorage.getItem('darkMode');
        if (savedMode === 'enabled') {
            body.classList.add('dark-mode');
        }
        darkModeToggle.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', body.classList.contains('dark-mode') ? 'enabled' : 'disabled');
        });

        // Global variables
        let currentData = null;
        let currentChart = null;
        const datasets = {
            stocks: '../data/processed/stock_market_processed.csv',
            crypto: '../data/processed/crypto_processed.csv',
            'crypto-risk': '../data/processed/crypto_risk_return.csv',
            sentiment: '../data/processed/social_sentiment_processed.csv',
            defi: '../data/processed/defi_historical_processed.csv'
        };

        // Load dataset
        function loadDataset(datasetName) {
            const filePath = datasets[datasetName];

            // Show loading state
            document.querySelector('.chart-container').innerHTML =
                '<div class="loading">Loading data...</div>';

            Papa.parse(filePath, {
                download: true,
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    if (!results.data || results.data.length === 0) {
                        document.querySelector('.chart-container').innerHTML =
                            '<div class="error">No data found. The CSV file may be empty or in an incorrect format.</div>';
                        return;
                    }
                    currentData = results.data.filter(row => Object.values(row).some(val => val !== null && val !== ''));
                    if (currentData.length === 0) {
                        document.querySelector('.chart-container').innerHTML =
                            '<div class="error">No valid data found after filtering.</div>';
                        return;
                    }
                    updateTickerOptions(datasetName);
                    updateChart();
                    updateStats(datasetName);
                },
                error: function(error) {
                    console.error('Error loading data:', error);
                    document.querySelector('.chart-container').innerHTML =
                        `<div class="error">
                            <strong>Error loading data file: ${filePath}</strong><br><br>
                            This may happen when running the site locally due to browser CORS restrictions.<br><br>
                            <strong>Solutions:</strong><br>
                            1. Make sure you're running a local server (python -m http.server 8000)<br>
                            2. Access the site via http://localhost:8000/site/playground.html (not via file://)<br>
                            3. Check that the data files exist in the ../data/processed/ directory<br><br>
                            <strong>Technical details:</strong> ${error.message || 'Unknown error'}
                        </div>`;
                }
            });
        }

        // Update ticker/asset selector based on dataset
        function updateTickerOptions(datasetName) {
            const tickerSelect = document.getElementById('ticker-select');
            tickerSelect.innerHTML = '<option value="all" selected>All Assets</option>';

            let uniqueValues = new Set();

            if (datasetName === 'stocks' && currentData[0]?.ticker) {
                currentData.forEach(row => uniqueValues.add(row.ticker));
            } else if ((datasetName === 'crypto' || datasetName === 'sentiment') && currentData[0]?.coin) {
                currentData.forEach(row => uniqueValues.add(row.coin));
            } else if (datasetName === 'defi' && currentData[0]?.protocol) {
                currentData.forEach(row => uniqueValues.add(row.protocol));
            } else if (datasetName === 'crypto-risk' && currentData[0]?.coin) {
                currentData.forEach(row => uniqueValues.add(row.coin));
            }

            Array.from(uniqueValues).sort().forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                tickerSelect.appendChild(option);
            });
        }

        // Update statistics
        function updateStats(datasetName) {
            const statsContainer = document.getElementById('stats-container');
            let statsHTML = '';

            if (!currentData || currentData.length === 0) return;

            // Calculate stats based on dataset type
            if (datasetName === 'stocks') {
                const avgClose = currentData.reduce((sum, row) => sum + (row.close || 0), 0) / currentData.length;
                const avgVolume = currentData.reduce((sum, row) => sum + (row.volume || 0), 0) / currentData.length;
                const uniqueTickers = new Set(currentData.map(row => row.ticker)).size;

                statsHTML = `
                    <div class="stat-card">
                        <div class="stat-value">$${avgClose.toFixed(2)}</div>
                        <div class="stat-label">Avg Price</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${(avgVolume / 1e6).toFixed(1)}M</div>
                        <div class="stat-label">Avg Volume</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${uniqueTickers}</div>
                        <div class="stat-label">Stocks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${currentData.length}</div>
                        <div class="stat-label">Data Points</div>
                    </div>
                `;
            } else if (datasetName === 'crypto') {
                const avgPrice = currentData.reduce((sum, row) => sum + (row.price || 0), 0) / currentData.length;
                const uniqueCoins = new Set(currentData.map(row => row.coin)).size;

                statsHTML = `
                    <div class="stat-card">
                        <div class="stat-value">$${avgPrice.toFixed(0)}</div>
                        <div class="stat-label">Avg Price</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${uniqueCoins}</div>
                        <div class="stat-label">Cryptocurrencies</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${currentData.length}</div>
                        <div class="stat-label">Data Points</div>
                    </div>
                `;
            } else if (datasetName === 'crypto-risk') {
                const avgReturn = currentData.reduce((sum, row) => sum + (row.annualized_return || 0), 0) / currentData.length;
                const avgVolatility = currentData.reduce((sum, row) => sum + (row.avg_volatility || 0), 0) / currentData.length;

                statsHTML = `
                    <div class="stat-card">
                        <div class="stat-value">${avgReturn.toFixed(1)}%</div>
                        <div class="stat-label">Avg Return</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${avgVolatility.toFixed(1)}%</div>
                        <div class="stat-label">Avg Volatility</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${currentData.length}</div>
                        <div class="stat-label">Assets</div>
                    </div>
                `;
            } else if (datasetName === 'sentiment') {
                const avgSentiment = currentData.reduce((sum, row) => sum + (row.sentiment_score || 0), 0) / currentData.length;
                const uniqueCoins = new Set(currentData.map(row => row.coin)).size;

                statsHTML = `
                    <div class="stat-card">
                        <div class="stat-value">${avgSentiment.toFixed(1)}</div>
                        <div class="stat-label">Avg Sentiment</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${uniqueCoins}</div>
                        <div class="stat-label">Coins Tracked</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${currentData.length}</div>
                        <div class="stat-label">Data Points</div>
                    </div>
                `;
            } else if (datasetName === 'defi') {
                const avgTVL = currentData.reduce((sum, row) => sum + (row.tvl_millions || 0), 0) / currentData.length;
                const uniqueProtocols = new Set(currentData.map(row => row.protocol)).size;

                statsHTML = `
                    <div class="stat-card">
                        <div class="stat-value">$${avgTVL.toFixed(0)}M</div>
                        <div class="stat-label">Avg TVL</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${uniqueProtocols}</div>
                        <div class="stat-label">Protocols</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${currentData.length}</div>
                        <div class="stat-label">Data Points</div>
                    </div>
                `;
            }

            statsContainer.innerHTML = statsHTML;
        }

        // Update chart
        function updateChart() {
            const datasetName = document.getElementById('dataset-select').value;
            const chartType = document.getElementById('chart-type').value;
            const tickerSelect = document.getElementById('ticker-select');
            const selectedTickers = Array.from(tickerSelect.selectedOptions).map(opt => opt.value);

            if (!currentData) return;

            // Filter data
            let filteredData = currentData;
            if (!selectedTickers.includes('all')) {
                const tickerField = datasetName === 'stocks' ? 'ticker' :
                                   (datasetName === 'defi' ? 'protocol' : 'coin');
                filteredData = currentData.filter(row => selectedTickers.includes(row[tickerField]));
            }

            // Validate filtered data
            if (!filteredData || filteredData.length === 0) {
                if (currentChart) {
                    currentChart.destroy();
                    currentChart = null;
                }
                const chartContainer = document.querySelector('.chart-container');
                chartContainer.innerHTML =
                    '<div class="error">No data available for the selected filters. Please choose different options.</div>' +
                    '<canvas id="main-chart" class="chart-canvas"></canvas>';
                return;
            }

            // Restore canvas if it was replaced by error message
            const chartContainer = document.querySelector('.chart-container');
            if (!document.getElementById('main-chart')) {
                chartContainer.innerHTML = '<canvas id="main-chart" class="chart-canvas"></canvas>';
            }

            // Prepare chart data
            const ctx = document.getElementById('main-chart');

            if (currentChart) {
                currentChart.destroy();
            }

            let chartData = prepareChartData(datasetName, filteredData, chartType);

            currentChart = new Chart(ctx, {
                type: chartType,
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: chartType !== 'scatter' ? {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: getXAxisLabel(datasetName)
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: getYAxisLabel(datasetName)
                            }
                        }
                    } : {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: getXAxisLabel(datasetName)
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: getYAxisLabel(datasetName)
                            }
                        }
                    }
                }
            });
        }

        // Prepare chart data based on dataset
        function prepareChartData(datasetName, data, chartType) {
            const colors = ['#667eea', '#764ba2', '#f18f01', '#2e86ab', '#a23b72', '#27ae60', '#e74c3c'];

            if (datasetName === 'stocks') {
                const groupedByTicker = {};
                data.forEach(row => {
                    if (row.ticker) {
                        if (!groupedByTicker[row.ticker]) {
                            groupedByTicker[row.ticker] = [];
                        }
                        groupedByTicker[row.ticker].push(row);
                    }
                });

                const datasets = Object.keys(groupedByTicker).map((ticker, idx) => ({
                    label: ticker,
                    data: chartType === 'scatter'
                        ? groupedByTicker[ticker].map(row => ({ x: (row.volume || 0) / 1e6, y: row.close || 0 }))
                        : groupedByTicker[ticker].map(row => row.close || 0),
                    borderColor: colors[idx % colors.length],
                    backgroundColor: colors[idx % colors.length] + '40',
                    tension: 0.1
                }));

                const firstKey = Object.keys(groupedByTicker)[0];
                return {
                    labels: chartType !== 'scatter' && firstKey ? groupedByTicker[firstKey].map(row => row.date || '') : undefined,
                    datasets: datasets
                };
            } else if (datasetName === 'crypto') {
                const groupedByCoin = {};
                data.forEach(row => {
                    if (row.coin) {
                        if (!groupedByCoin[row.coin]) {
                            groupedByCoin[row.coin] = [];
                        }
                        groupedByCoin[row.coin].push(row);
                    }
                });

                const datasets = Object.keys(groupedByCoin).map((coin, idx) => ({
                    label: coin,
                    data: chartType === 'scatter'
                        ? groupedByCoin[coin].map(row => ({ x: row.volume || 0, y: row.price || 0 }))
                        : groupedByCoin[coin].map(row => row.price || 0),
                    borderColor: colors[idx % colors.length],
                    backgroundColor: colors[idx % colors.length] + '40',
                    tension: 0.1
                }));

                const firstKey = Object.keys(groupedByCoin)[0];
                return {
                    labels: chartType !== 'scatter' && firstKey ? groupedByCoin[firstKey].map(row => row.date || '') : undefined,
                    datasets: datasets
                };
            } else if (datasetName === 'crypto-risk') {
                return {
                    labels: data.map(row => row.coin),
                    datasets: [{
                        label: chartType === 'scatter' ? 'Risk vs Return' : 'Total Return (%)',
                        data: chartType === 'scatter'
                            ? data.map(row => ({ x: row.avg_volatility, y: row.annualized_return }))
                            : data.map(row => row.annualized_return),
                        backgroundColor: colors,
                        borderColor: colors,
                        borderWidth: 2
                    }]
                };
            } else if (datasetName === 'sentiment') {
                const groupedByCoin = {};
                data.forEach(row => {
                    if (row.coin) {
                        if (!groupedByCoin[row.coin]) {
                            groupedByCoin[row.coin] = [];
                        }
                        groupedByCoin[row.coin].push(row);
                    }
                });

                const datasets = Object.keys(groupedByCoin).map((coin, idx) => ({
                    label: coin,
                    data: groupedByCoin[coin].map(row => row.sentiment_score || 0),
                    borderColor: colors[idx % colors.length],
                    backgroundColor: colors[idx % colors.length] + '40',
                    tension: 0.1
                }));

                const firstKey = Object.keys(groupedByCoin)[0];
                return {
                    labels: firstKey ? groupedByCoin[firstKey].map(row => row.date || '') : [],
                    datasets: datasets
                };
            } else if (datasetName === 'defi') {
                const groupedByProtocol = {};
                data.forEach(row => {
                    if (row.protocol) {
                        if (!groupedByProtocol[row.protocol]) {
                            groupedByProtocol[row.protocol] = [];
                        }
                        groupedByProtocol[row.protocol].push(row);
                    }
                });

                const datasets = Object.keys(groupedByProtocol).map((protocol, idx) => ({
                    label: protocol,
                    data: groupedByProtocol[protocol].map(row => row.tvl_millions || 0),
                    borderColor: colors[idx % colors.length],
                    backgroundColor: colors[idx % colors.length] + '40',
                    tension: 0.1
                }));

                const firstKey = Object.keys(groupedByProtocol)[0];
                return {
                    labels: firstKey ? groupedByProtocol[firstKey].map(row => row.date || '') : [],
                    datasets: datasets
                };
            }
        }

        function getXAxisLabel(datasetName) {
            const chartType = document.getElementById('chart-type').value;

            if (chartType === 'scatter') {
                if (datasetName === 'crypto-risk') return 'Volatility (%)';
                if (datasetName === 'stocks') return 'Volume (M)';
                if (datasetName === 'crypto') return 'Volume';
                return 'X-Axis';
            }

            if (datasetName === 'crypto-risk') return 'Cryptocurrency';
            return 'Date';
        }

        function getYAxisLabel(datasetName) {
            if (datasetName === 'stocks' || datasetName === 'crypto') return 'Price (USD)';
            if (datasetName === 'crypto-risk') return 'Total Return (%)';
            if (datasetName === 'sentiment') return 'Sentiment Score';
            if (datasetName === 'defi') return 'TVL (Millions USD)';
            return 'Value';
        }

        // Event listeners
        document.getElementById('dataset-select').addEventListener('change', (e) => {
            loadDataset(e.target.value);
        });

        document.getElementById('chart-type').addEventListener('change', () => {
            updateChart();
        });

        document.getElementById('ticker-select').addEventListener('change', () => {
            updateChart();
        });

        // Initial load
        loadDataset('stocks');
    </script>
</body>
</html>
